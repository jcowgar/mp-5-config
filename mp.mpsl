/*

	Jeremy's Minimum Profile Configuration File
	
	Last Updated: Apr 19 2011

	Windows: $HOMEDIR/Documents/.mp.mpsl
	Unices: $HOME/.mp.mpsl

	TODO:
		* Delete To functionality
		* Open project file list, like text mates M-T
*/

mp.syntax.tcl = {
	'id'	    =>  'tcl',
	'name'      =>  'tcl',
	'filenames' =>  [ '/\.tcl$/' ],
	'defs'      => [
		'word1', [ 
			mp.syn_token_list([
				"after", "append", "apply", "array", "auto_execok", "auto_import", "auto_load",
				"auto_mkindex", "auto_mkindex_old", "auto_qualify", "auto_reset", "bgerror",
				"binary", "break", "catch", "cd", "chan", "clock", "close", "concat", "continue",
				"dde", "dict", "else", "encoding", "eof", "error", "eval", "exec", "exit", "expr",
				"fblocked", "fconfigure", "fcopy", "file", "fileevent", "filename", "flust",
				"for", "foreach", "format", "gets", "glob", "global", "history", "http",  "if", 
				"incr", "info", "interp", "join", "lappend", "lassign", "lindex", "linsert",
				"list", "llength", "load", "lrange", "lrepeat", "lreplace", "lreverse", "lsearch",
				"lset", "lsort", "memory", "msgcat", "my", "namespace", "next", "oo::class", 
				"oo::copy", "oo::define", "oo::objdefine", "oo::object", "open", "package",
				"parray", "pid", "pkg::create", "pkg_mkIndex", "platform", "platform::shell",
				"prefix", "proc", "puts", "pwd", "read", "refchan", "regexp", "registry",
				"regsub", "rename", "return", "scan", "seek", "self", "set", "socket", "source",
				"split", "string", "subst", "switch", "tell", "throw", "time", "tm", "trace",
				"transchan", "try", "unknown", "unload", "unset", "update", "uplevel", "upvar",
				"variable", "vwait", "while", "zlib",
				"method", "snit", "widget", "hulltype", "delegate", "constructor", "destructor", 
				"to"
			])
		],
		'word2', [
			mp.syn_token_list([
				"bell","font","options","tk_chooseDirectory","tkvars","ttk::scale",
				"bind","fontchooser","pack","tk_dialog","tkwait","ttk::scrollbar",
				"bindtags","frame","panedwindow","tk_focusFollowsMouse","toplevel","ttk::separator",
				"bitmap","grab","photo","tk_focusNext","ttk::button","ttk::sizegrip",
				"busy","grid","place","tk_focusPrev","ttk::checkbutton","ttk::spinbox",
				"button","image","radiobutton","tk_getOpenFile","ttk::combobox","ttk::style",
				"canvas","keysyms","raise","tk_getSaveFile","ttk::entry","ttk::treeview",
				"checkbutton","label","scale","tk_menuSetFocus","ttk::frame","ttk::widget",
				"clipboard","labelframe","scrollbar","tk_messageBox","ttk_image",
				"colors","listbox","selection","tk_optionMenu","ttk::label","ttk_vsapi",
				"console","loadTk","send","tk_popup","ttk::labelframe","winfo",
				"cursors","lower","spinbox","tk_setPalette","ttk::menubutton","wm",
				"destroy","menu","text","tk_textCopy","ttk::notebook",
				"entry","menubutton","tk","tk_textCut","ttk::panedwindow",
				"event","message","tk_bisque","tk_textPaste","ttk::progressbar",
				"focus","option","tk_chooseColor","tkerror","ttk::radiobutton"
			])
		],
		'quotes',	[
			"/\"([^\"\\\\\n]*(\\\\.[^\"\\\\\n]*)*)\"/",    /* double-quoted strings */
			"/'([^'\\\\\n]*(\\\\.[^'\\\\\n]*)*)'/",        /* single-quoted strings */
			"/\b-?[0-9]+\b/"                               /* numbers */
		],
		'comments',		[ "/#.*$/m" ]
	],
	'section' => [ '/^[ \t]*(proc|method|typemethod)[ \t]*/' ]
};

sub first_non_whitespace(d) 
/* Return the first non-whitespace X location for current line */
{
	local i = 0;
	local l = split(d.txt.lines[d.txt.y]);

	while (i < size(l) && (cmp(l[i], " ") == 0 || cmp(l[i], "\t") == 0)) {
		i++;
	}

	return i;
}

sub indent_block(d) 
/* Indent the selected block or current line by one indentation unit */
{
	if (d.txt.mark == NULL) {
		mp.move(d, mp.move_bol);
		mp.insert_tab(d);
		return (NULL);
	}
	
	local currentY = d.txt.y;
	local startY   = d.txt.mark.by;
	local endY     = d.txt.mark.ey;
	
	mp.unmark(d);
	
	mp.set_y(d, startY);
	while (d.txt.y <= endY) {
		mp.move(d, mp.move_bol);
		mp.insert_tab(d);
		mp.move(d, mp.move_down);
	}
	
	mp.set_y(d, startY);
	mp.move(d, mp.move_bol);
	mp.mark(d);
	
	mp.set_y(d, endY);
	mp.move(d.mp_move_eol);
	mp.mark(d);
	
	mp.set_y(d, currentY);
}

mp.actions['indent_block'] = indent_block;
mp.actdesc['indent_block'] = "Indent block";

sub deindent_line(d)
/* Deindent the current line by 1 tab or the indent size */
{
	local l = split(d.txt.lines[d.txt.y]);
	
	mp.move(d, mp.move_bol);
	
	if (cmp(l[0], "\t") == 0) {
		mp.delete_char(d);
		
		return;
	} else {
		local i = 0;
		while (i < mp.config.tab_size) {
			if (cmp(l[i], " ") == 0) {
				mp.delete_char(d);
			} else {
				return;
			}
			
			i++;
		}
	}
	
	return;
}

sub deindent_block(d)
/* Deindent the selected block or current line by one indentation unit */
{
	if (d.txt.mark == NULL) {
		deindent_line(d);
		return NULL;
	}
	
	local currentY = d.txt.y;
	local startY   = d.txt.mark.by;
	local endY     = d.txt.mark.ey;
	
	mp.unmark(d);
	
	mp.set_y(d, startY);
	while (d.txt.y <= endY) {
		mp.move(d, mp.move_bol);
		if (first_non_whitespace(d) > 0)
			mp.delete_char(d);
		mp.move(d, mp.move_down);
	}
	
	mp.set_y(d, startY);
	mp.move(d, mp.move_bol);
	mp.mark(d);
	
	mp.set_y(d, endY);
	mp.move(d.mp_move_eol);
	mp.mark(d);
	
	mp.set_y(d, currentY);
}

mp.actions['deindent_block'] = deindent_block;
mp.actdesc['deindent_block'] = "Deindent block";

sub smart_home(d) 
/* Move to the first non-whitespace or BOL if already there */
{
	local newX = first_non_whitespace(d);
	
	if (d.txt.x == newX) {
		mp.set_x(d, 0);
	} else {
		mp.set_x(d, newX);
	}
}

mp.actions['smart_home'] = smart_home;
mp.actdesc['smart_home'] = "Smart home";

mp.keycodes['home']             = 'smart_home';
mp.keycodes['ctrl-cursor-up']   = 'prev';
mp.keycodes['ctrl-cursor-down'] = 'next';
mp.keycodes['ctrl-b']           = 'document_list';
mp.keycodes['ctrl-l']           = 'section_list';
mp.keycodes['alt-cursor-right'] = 'indent_block';
mp.keycodes['alt-cursor-left']  = 'deindent_block';

mp.config.auto_indent = 1;
mp.config.tab_size = 4;
mp.config.tabs_as_spaces = 0;
